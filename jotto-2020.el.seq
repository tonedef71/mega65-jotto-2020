'-----------------------------------------------------------------------------
'- jOTTO 2020 FOR THE mEGA65
'-----------------------------------------------------------------------------
' tHIS eLEVEN SOURCE FILE MAY BE USED TO GENERATE A TOKENIZED basic 65 prg
' FILE BY LOADING AND COMPILING WITHIN THE eLEVEN DEVELOPMENT ENVIRONMENT.
' tHE RESULTING prg FILE SHOULD REPLACE THE EXISTING ONE IN THE JOTTO 2020
' SETUP DISK BEFORE USING THE SETUP DISK TO CREATE A NEW RELEASE DISK.
'-----------------------------------------------------------------------------
#OUTPUT "JOTTO-2020"        ' OUTPUT FILE NAME

' ENTRY POINT
CLR:KEY OFF:MOUSE OFF

' *** CONSTANTS ***
#DECLARE MAXINT = $3B9AC9FF ' 999,999,999
#DECLARE TRUE  = -1
#DECLARE FALSE =  0
#DECLARE BLACK = 0
#DECLARE WHITE = 1
#DECLARE RED = 2
#DECLARE CYAN = 3
#DECLARE MAGENTA = 4
#DECLARE GREEN = 5
#DECLARE BLUE = 6
#DECLARE YELLOW = 7
#DECLARE DARKGREY = 11
#DECLARE BLANK = 32
#DECLARE HASH = 35
#DECLARE RBRACE = 93
#DECLARE P_ORANGE = 129
#DECLARE BLACK$
BLACK$ = CHR$(144)
#DECLARE WHITE$
WHITE$ = CHR$(5)
#DECLARE RED$
RED$ = CHR$(28)
#DECLARE ORANGE$
ORANGE$ = CHR$(P_ORANGE)
#DECLARE CYAN$
CYAN$ = CHR$(159)
#DECLARE MAGENTA$
MAGENTA$ = CHR$(156)
#DECLARE GREEN$
GREEN$ = CHR$(30)
#DECLARE BLUE$
BLUE$ = CHR$(31)
#DECLARE YELLOW$
YELLOW$ = CHR$(158)
#DECLARE DARKGREY$
DARKGREY$ = CHR$(151)
#DECLARE ESC$
ESC$ = CHR$(27)
#DECLARE RVSON$
RVSON$ = CHR$(18)
#DECLARE RVSOFF$
RVSOFF$ = CHR$(146)
#DECLARE BACK_SPACE$
BACK_SPACE$ = CHR$(20)
#DECLARE CR$
CR$ = CHR$(13)
#DECLARE CRLEFT$
CRLEFT$ = CHR$(157)
#DECLARE UPPERCASE$
UPPERCASE$ = CHR$(142)

' *** GLOBAL VARS ***
#DECLARE GAME_NAME$ = "JOTTO-2020"
#DECLARE ROTATION_AMOUNT% = 12
#DECLARE MINIMUM_ALLOWED_GUESSES& = 5
#DECLARE LOWEST_WORD_LENGTH& = 2
#DECLARE HIGHEST_WORD_LENGTH& = 12
#DECLARE STRICTLY_WORD_GUESSES%
#DECLARE HARD_MODE%
#DECLARE MAXIMUM_TURNS&
#DECLARE SOLVED$
#DECLARE LETTER_STATES$
#DECLARE LOST%
#DECLARE GUESS_COUNT&
#DECLARE CURRENT_LINE&
#DECLARE TARGET$
#DECLARE FRAME_1& = 200
#DECLARE FRAME_SEQUENCE$ = "0123456780"  ' FRAME_1& + VAL(MID$(FRAME_SEQUENCE$, LI%, 1))
#DECLARE FRAME_COUNT&
FRAME_COUNT& = LEN(FRAME_SEQUENCE$) - 1 ' := 9
#DECLARE SCREEN_HEIGHT% ' GLOBAL SCREEN HEIGHT
#DECLARE SCREEN_WIDTH% ' GLOBAL SCREEN WIDTH
#DECLARE C_AICP$ = " .*?"
#DECLARE COL_AICP$
COL_AICP$ = WHITE$+RED$+GREEN$+YELLOW$
#DECLARE C_BLANK& = 1
#DECLARE C_ABSENT& = 2
#DECLARE C_CORRECT& = 3
#DECLARE C_PRESENT& = 4
#DECLARE RECORD_COUNTS%  ' RECORD COUNTS FOR EACH WORD LENGTH (PLAYABLE WORD COUNT AND DICTIONARY WORD COUNT)
DIM RECORD_COUNTS%(HIGHEST_WORD_LENGTH& - 2, 1)
#DECLARE BEST_SCORES&
DIM BEST_SCORES&(HIGHEST_WORD_LENGTH& - 2, 1)

' *** FUNCTION VARIABLES ***
#DECLARE F0RV%
#DECLARE F1HEIGHT% ' A2%
#DECLARE F1INDEX% ' L1%
#DECLARE F1POSITION% ' A0%
#DECLARE F1RV&
#DECLARE F1WIDTH% ' A1%
#DECLARE F2HI_VALUE% ' A1%
#DECLARE F2LO_VALUE% ' A0%
#DECLARE F2RV%
#DECLARE F3RV
#DECLARE F3VALUE_1 ' A0
#DECLARE F3VALUE_2 ' A1
#DECLARE F4I%
#DECLARE F4LENGTH% ' A1%
#DECLARE F4NUM$
#DECLARE F4RV$
#DECLARE F4VALUE% ' A0%
#DECLARE F5I%
#DECLARE F5NUM_CHARS%
#DECLARE F5RV$
#DECLARE F5TEXT_TO_REPEAT$
#DECLARE F6CHARACTER& ' A0&
#DECLARE F6RV%
#DECLARE F7COUNT% ' L0%
#DECLARE F7I& ' LI&
#DECLARE F7IS_PRINTABLE ' L2%
#DECLARE F7LEN& ' L1&
#DECLARE F7RV%
#DECLARE F7TEXT$ ' A0$
#DECLARE F8RV&
#DECLARE F8TEXT$ ' A0$
#DECLARE F9RV&
#DECLARE F9TEXT$
#DECLARE F10COUNT%
#DECLARE F10I%
#DECLARE F10LEN%
#DECLARE F10RV$
#DECLARE F10WORD$
#DECLARE F11BLANK_MASK$
#DECLARE F11DEFAULT_VALUE$
#DECLARE F11INPUT$
#DECLARE F11INPUT_KEY$
#DECLARE F11LEN&
#DECLARE F11MAX_LENGTH%
#DECLARE F11PROMPT_LABEL$
#DECLARE F11RV$
#DECLARE F11VALID_INPUT_CHARS$
#DECLARE F11X&
#DECLARE F11Y&
#DECLARE F12DEFAULT_VALUE$
#DECLARE F12MAX_DIGIT_COUNT%
#DECLARE F12PROMPT_LABEL$
#DECLARE F12RV%
#DECLARE F12X&
#DECLARE F12Y&
#DECLARE F13CHAR$
#DECLARE F13LEGAL_CHARS$
#DECLARE F13PROMPT_TEXT$
#DECLARE F13RV%
#DECLARE F13X&
#DECLARE F13Y&
#DECLARE F14FILENAME$
#DECLARE F14FOUND% ' L3%
#DECLARE F14FOUND_WORD$
#DECLARE F14HIGH ' L2
#DECLARE F14LOW ' L1
#DECLARE F14MID ' L4
#DECLARE F14RV
#DECLARE F14WORD_TO_GUESS$
#DECLARE F15I% ' L0%
#DECLARE F15INDEX% ' L2%
#DECLARE F15LENGTH& ' A0&
#DECLARE F15RV$
#DECLARE F15WORD_COUNT% ' L1%
#DECLARE F16FILE_NAME$
#DECLARE F16RV%
#DECLARE F16WORD_SIZE&
#DECLARE F17FILE_NAME$
#DECLARE F17RECORD_NUMBER
#DECLARE F17RV$
#DECLARE F17WORD_SIZE&
#DECLARE F18MESSAGE$ ' L3$
#DECLARE F18RV%
#DECLARE F18VALID_WORD% ' L2%
#DECLARE F18WORD$
#DECLARE F18WORD_INDEX ' L0
#DECLARE F18WORD_LENGTH& ' L1&
#DECLARE F19RV&
#DECLARE F19WORD_LENGTH&
#DECLARE F20CHAR$
#DECLARE F20LETTER$
#DECLARE F20RV%
#DECLARE F21CHAR$ ' L5$
#DECLARE F21COLOR$ ' L7%
#DECLARE F21EMPTY$ ' L3$
#DECLARE F21INPUT$ ' L8$
#DECLARE F21INPUT_LENGTH&
#DECLARE F21IS_VIABLE% ' L6%
#DECLARE F21RV$
#DECLARE F21VALID_WORD% 'L0%
#DECLARE F21X& ' L1&
#DECLARE F21Y& ' L2&
#DECLARE F22LETTER_TO_GUESS$
#DECLARE F22RV%
#DECLARE F23GUESS$
#DECLARE F23GUESS_CHAR$
#DECLARE F23I%
#DECLARE F23INDEX&
#DECLARE F23LEN&
#DECLARE F23MASK$
#DECLARE F23MASK_CHAR$
#DECLARE F23RV$
#DECLARE F23TARGET$
#DECLARE F23TARGET_CHAR$
#DECLARE F24NUM_GUESSES&
#DECLARE F24RV$

' *** PROCEDURE VARIABLES ***
#DECLARE P0I%
#DECLARE P1SIZE&
#DECLARE P1Y&
#DECLARE P2COUNT& ' L0&
#DECLARE P2GUESS$ ' L3$
#DECLARE P2MASK$ ' L4$
#DECLARE P2MAX_TURNS$ ' L2$
#DECLARE P2TURN_NUM$ ' L1$
#DECLARE P3COLOR$
#DECLARE P3TEXT$ ' L1$
#DECLARE P4I% ' LI%
#DECLARE P4TEXT$ ' L1$
#DECLARE P4X& ' L0&
#DECLARE P5BH% ' BH%
#DECLARE P5BW% ' BW%
#DECLARE P9CHAR& ' A6&
#DECLARE P9COLOR& ' A4&
#DECLARE P9HEIGHT% ' A3%
#DECLARE P9L0% ' L0%
#DECLARE P9L1% ' L1%
#DECLARE P9L2% ' L2%
#DECLARE P9L3% ' L3%
#DECLARE P9POS% ' A5%
#DECLARE P9WIDTH% ' A2%
#DECLARE P9X& ' A0%
#DECLARE P9XOFFSET% ' L4%
#DECLARE P9Y& ' A1%
#DECLARE P9YOFFSET% ' L5%
#DECLARE P10COLOR& ' A4&
#DECLARE P10DO_HOME% ' A5%
#DECLARE P10HEIGHT% ' A3%
#DECLARE P10I% ' LI%
#DECLARE P10WIDTH% ' A2%
#DECLARE P10X& ' A0%
#DECLARE P10Y& ' A1%
#DECLARE P11BORDER_HEIGHT% ' BH%
#DECLARE P11BORDER_WIDTH% ' BW%
#DECLARE P11BOX_COLOR& ' A4&
#DECLARE P11BOX_HEIGHT% ' A3%
#DECLARE P11BOX_WIDTH% ' A2%
#DECLARE P11BOX_X& ' A0%
#DECLARE P11BOX_Y& ' A1%
#DECLARE P11CHAR& ' L2&
#DECLARE P11COLOR& ' L6%
#DECLARE P11KEY$ ' L4$
#DECLARE P11PERIMETER% ' P%
#DECLARE P11POSITION% ' L3%
#DECLARE P12TEXT$
#DECLARE P13I& ' LI&
#DECLARE P13LEN& ' L0%
#DECLARE P13TEXT$ ' A0$
#DECLARE P13X& ' L1&
#DECLARE P13Y& ' L2%
#DECLARE P14COUNT% ' L1%
#DECLARE P14I& ' LI&
#DECLARE P14LEN% ' L0%
#DECLARE P14LINE% ' L2%
#DECLARE P14TEXT$ ' A0$
#DECLARE P15I% ' LI%
#DECLARE P16I% ' LI%
#DECLARE P17BEST_SCORE$
#DECLARE P17WORD_SIZE&
#DECLARE P18NUMBER_OF_GUESSES& ' A1&
#DECLARE P18WORD_SIZE& ' A0&
#DECLARE P19I% ' LI%
#DECLARE P20I% ' LI%
#DECLARE P21CURRENT_STATE%
#DECLARE P21FINAL_STATE%
#DECLARE P21LETTER$
#DECLARE P21STATE%
#DECLARE P22CHAR$
#DECLARE P22I%
#DECLARE P22X&
#DECLARE P22Y&
#DECLARE P23CHAR&
#DECLARE P23COL&
#DECLARE P23COLOR&
#DECLARE P23I%
#DECLARE P23SLEEP_TIME
#DECLARE P23X&
#DECLARE P23Y&
#DECLARE P24C$
#DECLARE P24COLOR%
#DECLARE P24FINAL%
#DECLARE P24GUESS$
#DECLARE P24GUESS_LEN%
#DECLARE P24I%
#DECLARE P24INDEX%
#DECLARE P24MASK$
#DECLARE P24TONE%
#DECLARE P24X&
#DECLARE P24Y&
#DECLARE P25CH1&
#DECLARE P25CH2&
#DECLARE P25COUNT%
#DECLARE P25I%
#DECLARE P25SLEEP_TIME
#DECLARE P25X&
#DECLARE P25Y&
#DECLARE P28I&

TRAP PROC29_HANDLE_ERROR
GOSUB PROC8_DEFAULT_COLORS:SCNCLR:PRINT ESC$;"4;"ESC$;"R";ESC$;"M";UPPERCASE$
GOSUB PROC0_SETUP
GOSUB PROC5_WELCOME
DO
  GOSUB PROC8_DEFAULT_COLORS
  GOSUB PROC1_NEW_GAME
  GOSUB PROC2_MAIN_LOOP ' INVOKE MAIN LOOP
  GOSUB PROC3_GAME_OVER
  GOSUB FN0_PLAY_AGAIN
  IF NOT F0RV% THEN GOSUB PROC4_GOODBYE:EXIT
LOOP
.END
GOSUB PROC8_DEFAULT_COLORS:CURSOR ON
PRINT ESC$;"N";ESC$;"L" ' RESTORE SCROLLING FUNCTION
END
 
' PROC_SETUP()
.PROC0_SETUP
SCREEN_HEIGHT% = RWINDOW(3):SCREEN_WIDTH% = RWINDOW(2)
FOR P0I% = LOWEST_WORD_LENGTH& TO HIGHEST_WORD_LENGTH&
  BEST_SCORES&(P0I% - 2, 0) = 0 ' INITIALIZE LAST PLAYED WORDS
  BEST_SCORES&(P0I% - 2, 1) = MINIMUM_ALLOWED_GUESSES& ' SET DEFAULT BEST SCORES
NEXT P0I%
GOSUB PROC15_READ_LAST_PLAYED_WORDS
GOSUB PROC6_DEFINE_BOX_CHARACTERS
GOSUB PROC7_DEFINE_FRAME_CHARS
SCNCLR
PRINT "INITIALIZING... PLEASE WAIT...";:GOSUB PROC28_READ_FILE_OF_RECORD_COUNTS
SLEEP 2
RETURN
 
' PROC_NEW_GAME()
.PROC1_NEW_GAME
SCNCLR
DO
  F12X& = 0:F12Y& = 0
  F12PROMPT_LABEL$ = "PUZZLE SIZE ("+MID$(STR$(LOWEST_WORD_LENGTH&), 2)+" -"+STR$(HIGHEST_WORD_LENGTH&)+"):"
  F12DEFAULT_VALUE$ = "5":F12MAX_DIGIT_COUNT% = 2
  GOSUB FN12_PROMPT_FOR_DIGITS
  P1SIZE& = F12RV%
LOOP UNTIL (P1SIZE& >= LOWEST_WORD_LENGTH&) AND (P1SIZE& <= HIGHEST_WORD_LENGTH&)
RCURSOR ,P1Y&
F13X& = 0:F13Y& = P1Y& + 1:F13PROMPT_TEXT$ = "STRICTLY WORD GUESSES?"
GOSUB FN13_SIMPLE_YES_NO_PROMPT
STRICTLY_WORD_GUESSES% = F13RV%
RCURSOR ,P1Y&
F13X& = 0:F13Y& = P1Y& + 1:F13PROMPT_TEXT$ = "FORBID ABSENT LETTERS?"
GOSUB FN13_SIMPLE_YES_NO_PROMPT
HARD_MODE% = F13RV%
GOSUB PROC19_BEST_SCORES_READ
F19WORD_LENGTH& = P1SIZE&:GOSUB FN19_COMPUTE_MAXIMUM_TURNS
MAXIMUM_TURNS& = F19RV&
F5NUM_CHARS% = P1SIZE&:F5TEXT_TO_REPEAT$ = MID$(C_AICP$, C_CORRECT&, 1):GOSUB FN5_GEN_STRING
SOLVED$ = F5RV$
F5NUM_CHARS% = 26:F5TEXT_TO_REPEAT$ = MID$(C_AICP$, C_BLANK&, 1):GOSUB FN5_GEN_STRING
LETTER_STATES$ = F5RV$
LOST% = FALSE
GUESS_COUNT& = 0
CURRENT_LINE& = 4
F15LENGTH& = P1SIZE&:GOSUB FN15_SELECT_A_MYSTERY_WORD
TARGET$ = F15RV$
RETURN
 
' PROC_MAIN_LOOP()
.PROC2_MAIN_LOOP
SCNCLR
P2COUNT& = 0
P17WORD_SIZE& = P1SIZE&:GOSUB PROC17_DISPLAY_BEST_SCORE
DO
  P22X& = 0:P22Y& = 0:GOSUB PROC22_DISPLAY_LETTER_STATES
  F4VALUE% = P2COUNT& + 1:F4LENGTH% = 2:GOSUB FN4_PAD_NUMBER:P2TURN_NUM$ = F4RV$
  F4VALUE% = MAXIMUM_TURNS&:F4LENGTH% = 2:GOSUB FN4_PAD_NUMBER:P2MAX_TURNS$ = F4RV$
  CURSOR 0, CURRENT_LINE&:PRINT CYAN$;P2TURN_NUM$;" OF ";P2MAX_TURNS$;"> ";WHITE$;
  GOSUB FN21_PROMPT_FOR_GUESS
  P2GUESS$ = F21RV$
  F23GUESS$ = P2GUESS$:F23TARGET$ = TARGET$:GOSUB FN23_COMPARE_GUESS
  P2MASK$ = F23RV$:PRINT" ";
  P24GUESS$ = P2GUESS$:P24MASK$ = P2MASK$:P24FINAL% = 0:GOSUB PROC24_REVEAL
  P2COUNT& = P2COUNT& + 1
  CURRENT_LINE& = CURRENT_LINE& + 1
LOOP UNTIL (P2MASK$ = SOLVED$) OR (P2COUNT& = MAXIMUM_TURNS&)
LOST% = (P2MASK$ <> SOLVED$) ' WIN OR LOSE?
PRINT CYAN$;
P25X& = 0:P25Y& = CURRENT_LINE&:P25COUNT% = 10 + P1SIZE&:P25CH1& = ASC(">"):P25CH2& = ASC("-"):P25SLEEP_TIME = .12
GOSUB PROC25_SUSPENSE:PRINT WHITE$;
IF LOST% THEN BEGIN
' LOSS
  F10WORD$ = TARGET$:F10COUNT% = ROTATION_AMOUNT%:GOSUB FN10_ROTATE:TARGET$ = F10RV$
  P24GUESS$ = TARGET$:P24MASK$ = SOLVED$:P24FINAL% = TRUE:GOSUB PROC24_REVEAL
  GOSUB PROC27_WAH_WAH
BEND:ELSE BEGIN
' WIN
  PRINT ORANGE$;RVSON$;P2GUESS$;RVSOFF$
  GOSUB PROC26_CHARGE
  F3VALUE_1 = P2COUNT&:F3VALUE_2 = MAXIMUM_TURNS&:GOSUB FN3_MIN
  P18WORD_SIZE& = P1SIZE&:P18NUMBER_OF_GUESSES& = F3RV:GOSUB PROC18_UPDATE_BEST_SCORE
  P17WORD_SIZE& = P1SIZE&:GOSUB PROC17_DISPLAY_BEST_SCORE
BEND
P22X& = 0:P22Y& = 0:GOSUB PROC22_DISPLAY_LETTER_STATES
GOSUB PROC20_BEST_SCORES_WRITE
GUESS_COUNT& = P2COUNT&
RETURN
 
' PROC_GAME_OVER()
.PROC3_GAME_OVER
IF LOST% THEN BEGIN
  P3COLOR$ = RED$:P3TEXT$ = "SO SORRY! YOU LOST."
BEND:ELSE BEGIN
  P3COLOR$ = GREEN$
  F24NUM_GUESSES& = GUESS_COUNT&:GOSUB FN24_DERIVE_SUPERLATIVE:P3TEXT$ = F24RV$ + "!!"
BEND
CURSOR INT((SCREEN_WIDTH% - LEN(P3TEXT$)) / 2), GUESS_COUNT& + 6:PRINT P3COLOR$;P3TEXT$
SLEEP 2
RETURN
 
' FN_PLAY_AGAIN()
.FN0_PLAY_AGAIN
F13PROMPT_TEXT$ = "PLAY AGAIN?"
F13X& = INT((SCREEN_WIDTH% - LEN(F13PROMPT_TEXT$) - 8) / 2):F13Y& = GUESS_COUNT& + 8
FOREGROUND 7:GOSUB FN13_SIMPLE_YES_NO_PROMPT
F0RV% = F13RV%
RETURN
 
' PROC_GOODBYE()
.PROC4_GOODBYE
CURSOR OFF
SCNCLR
P12TEXT$ = "SO LONG AND THANK YOU FOR PLAYING..."
FOREGROUND 7:GOSUB PROC12_FULL_CENTER_TEXT
F9TEXT$ = GAME_NAME$
GOSUB FN9_CENTER_TEXT:P4X& = F9RV&
FOR P4I% = 0 TO P4X& - 1
  F5NUM_CHARS% = P4I%:F5TEXT_TO_REPEAT$ = CHR$(BLANK):GOSUB FN5_GEN_STRING:P4TEXT$ = F5RV$
  CURSOR 0, INT(SCREEN_HEIGHT% / 2) + 2:FOREGROUND MOD(P4I%, 7) + 1:PRINT P4TEXT$;GAME_NAME$:SLEEP .2
NEXT P4I%
RETURN
 
' PROC_WELCOME()
.PROC5_WELCOME
CURSOR OFF
SCNCLR
CURSOR 0, 2
P13TEXT$="WELCOME TO ...":GOSUB PROC13_CENTER:PRINT:PRINT
P14TEXT$="030032032032032032032032032032032032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="032032032103032032103032098099032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="032032032096098099096103096096032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="032032032096096096096096096096032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="032032101100096096096096101100032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="032032032032101100032096032032032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="032032032032032032032032032032032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="158098099098099098099098099032032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="098100096096098100096096032032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="096032096096096032096096032032":GOSUB PROC14_BANNER:PRINT
P14TEXT$="101097101100101097101100032032":GOSUB PROC14_BANNER:PRINT
FOREGROUND 3:PRINT:P13TEXT$="HIT A KEY TO CONTINUE ":GOSUB PROC13_CENTER
F3VALUE_1 = SCREEN_WIDTH%:F3VALUE_2 = 40:GOSUB FN3_MIN:P5BW% = F3RV
F3VALUE_1 = SCREEN_HEIGHT%:F3VALUE_2 = 20:GOSUB FN3_MIN:P5BH% = F3RV
P11BOX_X& = INT((SCREEN_WIDTH% - P5BW%) / 2) + 1:P11BOX_Y& = 1
P11BOX_WIDTH% = P5BW% - 2:P11BOX_HEIGHT% = P5BH% - 2
P11BOX_COLOR& = 3:GOSUB PROC11_ANIMATION
 
SCNCLR
CURSOR 0, 2
P13TEXT$=RED$+"JOTTO 2020"+WHITE$+" IS A MODERN VARIANT OF":GOSUB PROC13_CENTER:PRINT
P13TEXT$=GREEN$+"JOTTO"+WHITE$+", THE CLASSIC PEN AND PAPER ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="WORD GUESSING GAME. THE OBJECT OF":GOSUB PROC13_CENTER:PRINT
P13TEXT$="THE GAME IS TO GUESS THE MYSTERY ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="ENGLISH WORD WITH A LETTER LENGTH":GOSUB PROC13_CENTER:PRINT
P13TEXT$="BETWEEN 2 AND 12 (YOUR CHOOSING).":GOSUB PROC13_CENTER:PRINT
P13TEXT$="AFTER EACH GUESS YOU WILL GET TO ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="SEE A REPORT OF THE LETTERS (OR  ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="JOTS) IN THE GUESS THAT MATCH OR ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="OCCUR IN THE MYSTERY WORD...     ":GOSUB PROC13_CENTER:PRINT:PRINT
FOREGROUND 3:PRINT:P13TEXT$="HIT A KEY TO CONTINUE ":GOSUB PROC13_CENTER
F3VALUE_1 = SCREEN_HEIGHT%:F3VALUE_2 = 17:GOSUB FN3_MIN:P5BH% = F3RV
P11BOX_X& = INT((SCREEN_WIDTH% - P5BW%) / 2) + 1:P11BOX_Y& = 1
P11BOX_WIDTH% = P5BW% - 2:P11BOX_HEIGHT% = P5BH% - 2
P11BOX_COLOR& = 3:GOSUB PROC11_ANIMATION
 
GOSUB PROC8_DEFAULT_COLORS:SCNCLR:CURSOR OFF
CURSOR 0, 2
P13TEXT$=RED$+RVSON$+"A"+RVSOFF$+WHITE$
P13TEXT$=P13TEXT$+": ABSENT FROM MYSTERY WORD        ":GOSUB PROC13_CENTER:PRINT:PRINT
P13TEXT$=YELLOW$+RVSON$+"A"+RVSOFF$+WHITE$
P13TEXT$=P13TEXT$+": PRESENT *BUT* IMPROPERLY LOCATED":GOSUB PROC13_CENTER:PRINT:PRINT
P13TEXT$=GREEN$+RVSON$+"A"+RVSOFF$+WHITE$
P13TEXT$=P13TEXT$+": PRESENT *AND* PERFECTLY LOCATED ":GOSUB PROC13_CENTER:PRINT:PRINT
P13TEXT$="THROUGH A PROCESS OF ELIMINATION,":GOSUB PROC13_CENTER:PRINT
P13TEXT$="YOU SHOULD BE ABLE TO DEDUCE THE ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="CORRECT LETTERS USING LOGIC.     ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="THE NUMBER OF ALLOWED GUESSES FOR":GOSUB PROC13_CENTER:PRINT
P13TEXT$="SOLVING THE MYSTERY WORD IS BASED":GOSUB PROC13_CENTER:PRINT
P13TEXT$="ON THE LENGTH OF THE MYSTERY     ":GOSUB PROC13_CENTER:PRINT
P13TEXT$="WORD, BUT THE MINIMUM IS FIVE.   ":GOSUB PROC13_CENTER:PRINT:PRINT
P13TEXT$=WHITE$+"GOOD LUCK AND HAVE FUN!":GOSUB PROC13_CENTER:PRINT:PRINT
FOREGROUND 5:P13TEXT$="HIT A KEY TO BEGIN PLAYING ":GOSUB PROC13_CENTER
F3VALUE_1 = SCREEN_HEIGHT%:F3VALUE_2 = 21:GOSUB FN3_MIN:P5BH% = F3RV
P11BOX_X& = INT((SCREEN_WIDTH% - P5BW%) / 2) + 1:P11BOX_Y& = 1
P11BOX_WIDTH% = P5BW% - 2:P11BOX_HEIGHT% = P5BH% - 2
P11BOX_COLOR& = 3:GOSUB PROC11_ANIMATION
RETURN
 
' PROC_DEFINE_BOX_CHARACTERS
.PROC6_DEFINE_BOX_CHARACTERS
CHARDEF 64,24,24,24,24,24,24,24,24 ' VERTICAL
CHARDEF 65,.,.,.,255,255,.,.,. ' HORIZONTAL
CHARDEF 66,.,.,.,7,15,28,24,24 ' UPRIGHT C
CHARDEF 67,.,.,.,224,240,56,24,24 ' UPLEFT C
CHARDEF 68,24,24,56,240,224,.,.,. ' DOWNLEFT C
CHARDEF 69,24,24,28,15,7,.,.,. ' DOWN RIGHT C
CHARDEF 70,24,24,24,255,255,.,.,. ' UP T
CHARDEF 71,.,.,.,255,255,24,24,24 ' DOWN T
RETURN
 
' PROC_DEFINE_FRAME_CHARS
.PROC7_DEFINE_FRAME_CHARS
CHARDEF FRAME_1&,255,255,255,255,255,255,255,255
CHARDEF FRAME_1& + 1,127,255,255,255,255,255,255,254
CHARDEF FRAME_1& + 2,62,126,126,126,126,126,126,124
CHARDEF FRAME_1& + 3,28,60,60,60,60,60,60,56
CHARDEF FRAME_1& + 4,28,28,28,28,28,28,28,28
CHARDEF FRAME_1& + 5,56,60,60,60,60,60,60,28
CHARDEF FRAME_1& + 6,124,126,126,126,126,126,126,62
CHARDEF FRAME_1& + 7,124,126,126,126,126,126,126,62
CHARDEF FRAME_1& + 8,254,255,255,255,255,255,255,127
RETURN
 
' PROC_DEFAULT_COLORS
.PROC8_DEFAULT_COLORS
BORDER 5:BACKGROUND 0:FOREGROUND 1
RETURN
 
' FN_CLOCKWISE_BOX_SIDE_CHAR(POSITION%, WIDTH%, HEIGHT%)
.FN1_CLOCKWISE_BOX_SIDE_CHAR
' 0 = UPPER LEFT CORNER, 1 = UPPER MIDDLE, 2 = UPPER RIGHT CORNER,
' 3 = MIDDLE RIGHT, 4 = LOWER RIGHT CORNER, 5 = LOWER MIDDLE,
' 6 = LOWER LEFT CORNER, 7 = MIDDLE LEFT
' RV& IS RETURNED
F1INDEX% = 0
IF (F1POSITION% > 0 AND F1POSITION% < F1WIDTH% - 1) THEN F1INDEX% = 1
IF (F1POSITION% = F1WIDTH% - 1) THEN F1INDEX% = 2
IF (F1POSITION% >= F1WIDTH% AND F1POSITION% < F1WIDTH% + F1HEIGHT% - 2) THEN F1INDEX% = 3
IF (F1POSITION% = F1WIDTH% + F1HEIGHT% - 2) THEN F1INDEX% = 4
IF (F1POSITION% > F1WIDTH% + F1HEIGHT% - 2 AND F1POSITION% < 2 * F1WIDTH% + F1HEIGHT% - 3) THEN F1INDEX% = 5
IF (F1POSITION% = 2 * F1WIDTH% + F1HEIGHT% - 3) THEN F1INDEX% = 6
IF (F1POSITION% > 2 * F1WIDTH% + F1HEIGHT% - 3) THEN F1INDEX% = 7
F1RV& = VAL(MID$("6665676468656964", F1INDEX% * 2 + 1, 2))
RETURN
 
' PROC_CLOCKWISE_PLOT(X&, Y&, WIDTH%, HEIGHT%, COLOR&, POS%, CHAR&)
.PROC9_CLOCKWISE_PLOT
P9L0% = P9WIDTH% + P9HEIGHT% - 2:P9L1% = P9L0% + P9WIDTH%:P9L2% = P9L1% + P9HEIGHT% - 2
P9XOFFSET% = 0
IF (P9POS% < P9WIDTH%) THEN P9XOFFSET% = P9POS%
IF (P9POS% > (P9WIDTH% - 1) AND P9POS% < P9L0%) THEN P9XOFFSET% = P9WIDTH% - 1
IF (P9POS% >= P9L0% AND P9POS% < P9L1%) THEN P9XOFFSET% = P9L1% - P9POS% - 1
P9YOFFSET% = 0
IF (P9POS% > (P9WIDTH% - 1) AND P9POS% < P9L0%) THEN P9YOFFSET% = P9POS% - P9WIDTH% + 1
IF (P9POS% >= P9L0% AND P9POS% < P9L1%) THEN P9YOFFSET% = P9HEIGHT% - 1
IF (P9POS% >= P9L1%) THEN P9YOFFSET% = P9HEIGHT% - 2 - P9POS% + P9L1%
T@&(P9X& + P9XOFFSET%, P9Y& + P9YOFFSET%) = P9CHAR&
C@&(P9X& + P9XOFFSET%, P9Y& + P9YOFFSET%) = P9COLOR&
RETURN
 
' PROC_CLOCKWISE_BOX(X&, Y&, WIDTH%, HEIGHT%, COLOR&, DO_HOME%)
.PROC10_CLOCKWISE_BOX
' DO_HOME% = FLAG (0 = DO NOT POSITION CURSOR TO UPPERLEFT CORNER IN BOX)
FOR P10I% = 0 TO (P10WIDTH% + P10HEIGHT% + P10WIDTH% + P10HEIGHT% - 5)
  F1POSITION% = P10I%:F1WIDTH% = P10WIDTH%:F1HEIGHT% = P10HEIGHT% ' SET NEW ARGUMENTS
  GOSUB FN1_CLOCKWISE_BOX_SIDE_CHAR
  P9X& = P10X&:P9Y& = P10Y&:P9WIDTH% = P10WIDTH%
  P9HEIGHT% = P10HEIGHT%:P9COLOR& = P10COLOR&
  P9POS% = P10I%:P9CHAR& = F1RV& ' SET EXTRA ARGUMENTS
  GOSUB PROC9_CLOCKWISE_PLOT
NEXT P10I%
IF P10DO_HOME% THEN CURSOR P10X& + 1, P10Y& + 1
RETURN
 
' PROC_ANIMATION(BOX_X&, BOX_Y&, BOX_WIDTH%, BOX_HEIGHT%, BOX_COLOR&)
.PROC11_ANIMATION
P10X& = P11BOX_X&:P10Y& = P11BOX_Y&:P10WIDTH% = P11BOX_WIDTH%
P10HEIGHT% = P11BOX_HEIGHT%:P10COLOR& = P11BOX_COLOR&
P10DO_HOME% = 0:GOSUB PROC10_CLOCKWISE_BOX
F2LO_VALUE% = 1:F2HI_VALUE% = 26:GOSUB FN2_RND_INT:P11CHAR& = F2RV%
P11POSITION% = 0:P11KEY$ = ""
P11COLOR& = RCOLOR(1)
P11BORDER_HEIGHT% = P11BOX_HEIGHT% + 2
P11BORDER_WIDTH% = P11BOX_WIDTH% + 2
P11PERIMETER% = 2 * (P11BOX_WIDTH% + P11BOX_HEIGHT%) + 4
DO
  GET P11KEY$
  P11CHAR& = MOD(P11CHAR& + 1, 26) + 1
  P11POSITION% = MOD(P11POSITION% + 1, P11PERIMETER%)
  IF P11POSITION% = 1 THEN P11COLOR& = MOD((P11COLOR& + 1), 7) + 1
  P9X& = INT((SCREEN_WIDTH% - P11BORDER_WIDTH%) / 2):P9Y& = 0:P9WIDTH% = P11BORDER_WIDTH%:P9HEIGHT% = P11BORDER_HEIGHT% 
  P9COLOR& = P11COLOR&:P9POS% = P11POSITION%:P9CHAR& = P11CHAR&
  GOSUB PROC9_CLOCKWISE_PLOT
  VSYNC 0:SLEEP .1
  P9X& = INT((SCREEN_WIDTH% - P11BORDER_WIDTH%) / 2):P9Y& = 0:P9WIDTH% = P11BORDER_WIDTH%:P9HEIGHT% = P11BORDER_HEIGHT% 
  P9COLOR& = RCOLOR(0):P9POS% = P11POSITION%:P9CHAR& = BLANK
  GOSUB PROC9_CLOCKWISE_PLOT
LOOP UNTIL P11KEY$ <> ""
RETURN
 
' FN_RND_INT(LO_VALUE%, HI_VALUE%)
.FN2_RND_INT
' RETURNS RV% A (NUMBER BETWEEN LO AND HI)
F2RV% = INT(RND(1) * (F2HI_VALUE% - F2LO_VALUE% + 1)) + F2LO_VALUE%
RETURN
 
' FN_MIN(VALUE_1, VALUE_2)
' RETURNS RV
.FN3_MIN
F3RV = F3VALUE_2 + (F3VALUE_1 < F3VALUE_2) * (F3VALUE_2 - F3VALUE_1)
RETURN
 
' FN_PAD_NUMBER(VALUE%, LENGTH%)
.FN4_PAD_NUMBER
' RV$ IS RETURNED
F4NUM$ = MID$(STR$(F4VALUE%), 2):F4RV$ = ""
FOR F4I% = 1 TO F4LENGTH% - LEN(F4NUM$):F4RV$ = F4RV$ + "0":NEXT F4I%
F4RV$ = F4RV$ + F4NUM$
RETURN
 
' FN_GEN_STRING(NUM_CHARS%, TEXT_TO_REPEAT$)
.FN5_GEN_STRING
' RV$ IS RETURNED
F5RV$ = "":FOR F5I% = 1 TO F5NUM_CHARS%:F5RV$ = F5RV$ + F5TEXT_TO_REPEAT$:NEXT F5I%
RETURN
 
' FN_IS_PRINTABLE(CHARACTER&)
.FN6_IS_PRINTABLE
' RETURNS RV% (0 = FALSE, -1 = TRUE)
F6RV% = ((F6CHARACTER& >= BLANK) AND (F6CHARACTER& <= 93)) OR ((F6CHARACTER& >= 96) AND (F6CHARACTER& <= 127))
F6RV% = F6RV% OR ((F6CHARACTER& >= 160) AND (F6CHARACTER& <= 255))
RETURN

' FN_STRICT_LEN(TEXT$)
.FN7_STRICT_LEN
' TEXT$ = TEXT TO COMPUTE PRINTABLE CHARACTER LENGTH FOR
' RETURNS RV% (LENGTH OF PRINTABLE TEXT)
F7COUNT% = 0:F7LEN& = LEN(F7TEXT$)
FOR F7I& = 1 TO F7LEN&
  F6CHARACTER& = ASC(MID$(F7TEXT$, F7I&, 1)):GOSUB FN6_IS_PRINTABLE:F7IS_PRINTABLE = F6RV%
  IF F7IS_PRINTABLE THEN F7COUNT% = F7COUNT% + 1
NEXT F7I&
F7RV% = F7COUNT%
RETURN
 
' FN_STRICT_CENTER_TEXT(TEXT$)
.FN8_STRICT_CENTER_TEXT
' RETURNS RV&
F7TEXT$ = F8TEXT$:GOSUB FN7_STRICT_LEN
F8RV& = INT((SCREEN_WIDTH% - F7RV%) / 2) - (0 = MOD(F7RV%, 2))
RETURN
 
' FN_CENTER_TEXT(TEXT$)
.FN9_CENTER_TEXT
' RETURNS RV&
F9RV& = INT((SCREEN_WIDTH% - LEN(F9TEXT$)) / 2)
RETURN
 
' PROC_FULL_CENTER_TEXT(TEXT$)
.PROC12_FULL_CENTER_TEXT
F9TEXT$ = P12TEXT$:GOSUB FN9_CENTER_TEXT
CURSOR F9RV&, INT(SCREEN_HEIGHT% / 2) - (0 = MOD(SCREEN_HEIGHT%, 2)):PRINT P12TEXT$;
RETURN
 
' PROC_CENTER(TEXT$)
.PROC13_CENTER
P13LEN& = LEN(P13TEXT$)
F8TEXT$ = P13TEXT$:GOSUB FN8_STRICT_CENTER_TEXT:P13X& = F8RV&
RCURSOR ,P13Y&:CURSOR P13X&, P13Y&
FOR P13I& = 1 TO P13LEN&
  PRINT MID$(P13TEXT$, P13I&, 1);
NEXT P13I&
RETURN
 
' PROC_BANNER(TEXT$)
.PROC14_BANNER
P14LEN% = LEN(P14TEXT$):P14COUNT% = 0
FOR P14I& = 1 TO P14LEN% STEP 3
  F6CHARACTER& = VAL(MID$(P14TEXT$, P14I&, 3)):GOSUB FN6_IS_PRINTABLE
  IF F6RV% THEN P14COUNT% = P14COUNT% + 1
NEXT P14I&
P14COUNT% = INT((SCREEN_WIDTH% - P14COUNT%) / 2) - (0 = MOD(P14COUNT%, 2))
RCURSOR ,P14LINE%:CURSOR P14COUNT%, P14LINE%
FOR P14I& = 1 TO P14LEN% STEP 3
  PRINT CHR$(VAL(MID$(P14TEXT$, P14I&, 3)));
NEXT P14I&
RETURN
 
' FN_ROTATE(WORD$, COUNT%)
.FN10_ROTATE
F10RV$ = "":F10LEN% = LEN(F10WORD$)
FOR F10I% = 1 TO F10LEN%
  F10RV$ = F10RV$ + CHR$(MOD(ASC(MID$(F10WORD$, F10I%, 1)) - ASC("A") + 26 - F10COUNT%, 26) + ASC("A"))
NEXT F10I%
RETURN
 
' FN_GENERIC_PROMPT(X&, Y&, PROMPT_LABEL$, DEFAULT_VALUE$, MAX_LENGTH%, VALID_INPUT_CHARS$)
.FN11_GENERIC_PROMPT
F11LEN& = LEN(F11PROMPT_LABEL$ + F11DEFAULT_VALUE$) + 1:F11INPUT$ = F11DEFAULT_VALUE$
F5NUM_CHARS% = F11LEN& + 2:F5TEXT_TO_REPEAT$ = " ":GOSUB FN5_GEN_STRING:F11BLANK_MASK$ = F5RV$
CURSOR F11X&, F11Y&:PRINT F11BLANK_MASK$
CURSOR F11X&, F11Y&:PRINT WHITE$;F11PROMPT_LABEL$;" ";YELLOW$;F11DEFAULT_VALUE$;
CURSOR F11X& + F11LEN&, F11Y&
DO
  IF LEN(F11INPUT$) > 0 THEN CURSOR ON:ELSE CURSOR OFF
  GETKEY F11INPUT_KEY$
  IF ((F11INPUT_KEY$ = BACK_SPACE$ OR F11INPUT_KEY$ = CRLEFT$) AND LEN(F11INPUT$) > 0) THEN BEGIN 
    F11INPUT$ = LEFT$(F11INPUT$, LEN(F11INPUT$) - 1):PRINT BACK_SPACE$;
  BEND
  IF (INSTR(F11VALID_INPUT_CHARS$, F11INPUT_KEY$) <> 0) AND (LEN(F11INPUT$) < F11MAX_LENGTH%) THEN BEGIN
    F11INPUT$ = F11INPUT$ + F11INPUT_KEY$:PRINT F11INPUT_KEY$;
  BEND
LOOP UNTIL F11INPUT_KEY$ = CR$
IF LEN(F11INPUT$) < 1 THEN F11INPUT$ = F11DEFAULT_VALUE$:PRINT F11INPUT$
F11RV$ = F11INPUT$
CURSOR OFF
RETURN
 
' FN_PROMPT_FOR_DIGITS(X&, Y&, PROMPT_LABEL$, DEFAULT_VALUE$, MAX_DIGIT_COUNT%)
.FN12_PROMPT_FOR_DIGITS
F11X& = F12X&:F11Y& = F12Y&:F11PROMPT_LABEL$ = F12PROMPT_LABEL$:F11DEFAULT_VALUE$ = F12DEFAULT_VALUE$
F11MAX_LENGTH% = F12MAX_DIGIT_COUNT%:F11VALID_INPUT_CHARS$ = "0123456789"
GOSUB FN11_GENERIC_PROMPT
F12RV% = VAL(F11RV$)
RETURN
 
' FN_SIMPLE_YES_NO_PROMPT(X&, Y&, PROMPT_TEXT$)
.FN13_SIMPLE_YES_NO_PROMPT
' RV% IS RETURNED (-1 FOR TRUE, 0 FOR FALSE)
F13PROMPT_TEXT$ = F13PROMPT_TEXT$ + " (Y/N)":F13LEGAL_CHARS$="NY"
CURSOR F13X&, F13Y&:PRINT WHITE$;F13PROMPT_TEXT$;" ";
DO:GETKEY F13CHAR$:LOOP UNTIL INSTR(F13LEGAL_CHARS$, F13CHAR$) > 0
F13RV% = ("Y" = F13CHAR$)
RETURN
 
' PROC_READ_LAST_PLAYED_WORDS()
.PROC15_READ_LAST_PLAYED_WORDS
DOPEN#1, "DAT01.BIN"
IF DS = 0 THEN BEGIN
  FOR P15I% = LOWEST_WORD_LENGTH& TO HIGHEST_WORD_LENGTH&:INPUT#1, BEST_SCORES&(P15I% - 2, 0):NEXT P15I%
BEND
DCLOSE#1
RETURN
 
' PROC_WRITE_LAST_PLAYED_WORDS()
.PROC16_WRITE_LAST_PLAYED_WORDS
DOPEN#2, "@DAT01.BIN", W
IF DS = 0 THEN BEGIN
  FOR P16I% = LOWEST_WORD_LENGTH& TO HIGHEST_WORD_LENGTH&:PRINT#2, BEST_SCORES&(P16I% - 2, 0):NEXT P16I%
BEND
DCLOSE#2
RETURN
 
' PROC_DISPLAY_BEST_SCORE(WORD_SIZE&)
.PROC17_DISPLAY_BEST_SCORE
P17BEST_SCORE$ = MID$(STR$(P17WORD_SIZE&), 2)
P17BEST_SCORE$ = ORANGE$+RVSON$+P17BEST_SCORE$+RVSOFF$+YELLOW$+" BEST:"+WHITE$
P17BEST_SCORE$ = P17BEST_SCORE$ + STR$(BEST_SCORES&(P17WORD_SIZE& - 2, 1)) + "/" + MID$(STR$(MAXIMUM_TURNS&), 2)
CURSOR SCREEN_WIDTH% - LEN(P17BEST_SCORE$) + 4, 0:PRINT P17BEST_SCORE$
RETURN
 
' PROC_UPDATE_BEST_SCORE(WORD_SIZE&, NUMBER_OF_GUESSES&)
.PROC18_UPDATE_BEST_SCORE
' CHECK IF BEST SCORE HAS BEEN SURPASSED AND UPDATE IF NEEDED
IF (BEST_SCORES&(P18WORD_SIZE& - 2, 1) > P18NUMBER_OF_GUESSES&) THEN BEST_SCORES&(P18WORD_SIZE& - 2, 1) = P18NUMBER_OF_GUESSES&
RETURN
 
' PROC_BEST_SCORES_READ
.PROC19_BEST_SCORES_READ
DOPEN#1, (GAME_NAME$ + ".HI")
IF DS = 0 THEN BEGIN
  FOR P19I% = LOWEST_WORD_LENGTH& TO HIGHEST_WORD_LENGTH&:INPUT#1, BEST_SCORES&(P19I% - 2, 1):NEXT P19I%
BEND
DCLOSE#1
RETURN
 
' PROC_BEST_SCORES_WRITE
.PROC20_BEST_SCORES_WRITE
DOPEN#2, ("@" + GAME_NAME$ + ".HI"), W
FOR P20I% = LOWEST_WORD_LENGTH& TO HIGHEST_WORD_LENGTH&:PRINT#2, BEST_SCORES&(P20I% - 2, 1):NEXT P20I%
DCLOSE#2
RETURN
 
' FN_BINARY_SEARCH(WORD_TO_GUESS$)
' RETURNS RV (0 = NOT FOUND)
.FN14_BINARY_SEARCH
F14LOW = 1:F14HIGH = RECORD_COUNTS%(P1SIZE& - 2, 1):F14FOUND% = FALSE:F14RV = 0
F14FILENAME$ = "DICT" + RIGHT$("0" + MID$(STR$(P1SIZE&), 2), 2)
DOPEN#1, (F14FILENAME$), L(P1SIZE&)
DO
  F14MID = INT((F14LOW + F14HIGH) / 2) ' MID POINT
  RECORD#1, F14MID, 1:INPUT#1, F14FOUND_WORD$
  IF F14FOUND_WORD$ < F14WORD_TO_GUESS$ THEN F14LOW = F14MID + 1 ' UPPER CHUNK
  IF F14FOUND_WORD$ > F14WORD_TO_GUESS$ THEN F14HIGH = F14MID - 1 ' LOWER CHUNK
  IF F14FOUND_WORD$ = F14WORD_TO_GUESS$ THEN F14RV = F14MID:F14FOUND% = TRUE ' FOUND
LOOP WHILE F14LOW <= F14HIGH AND NOT F14FOUND%
DCLOSE#1
RETURN
 
' FN_SELECT_A_MYSTERY_WORD(LENGTH&)
.FN15_SELECT_A_MYSTERY_WORD
' RETURN RV$
F15I% = F15LENGTH& - LOWEST_WORD_LENGTH&
F15WORD_COUNT% = RECORD_COUNTS%(F15I%, 0)
F15INDEX% = BEST_SCORES&(F15I%, 0) + 1
IF F15INDEX% > F15WORD_COUNT% THEN BEGIN
  F15INDEX% = 1
BEND
BEST_SCORES&(F15I%, 0) = F15INDEX%
GOSUB PROC16_WRITE_LAST_PLAYED_WORDS
F17FILE_NAME$ = "DATA" + RIGHT$("0" + MID$(STR$(F15LENGTH&), 2), 2):F17WORD_SIZE& = F15LENGTH&:F17RECORD_NUMBER = F15INDEX%
GOSUB FN17_FILE_READ_WORD
F15RV$ = F17RV$
RETURN
 
' FN_CONFIRM_FILE_EXISTS(FILE_NAME$, WORD_SIZE&)
.FN16_CONFIRM_FILE_EXISTS
' RETURNS RV% (-1 FOR TRUE OR 0 FOR FALSE)
DOPEN#1, (F16FILE_NAME$)
F16RV% = (DS = 0)
DCLOSE#1
RETURN
 
' FN_FILE_READ_WORD(FILE_NAME$, WORD_SIZE&, RECORD_NUMBER)
.FN17_FILE_READ_WORD
' RETURNS RV$
F17RV$ = ""
F16FILE_NAME$ = F17FILE_NAME$:F16WORD_SIZE& = F17WORD_SIZE&
GOSUB FN16_CONFIRM_FILE_EXISTS
IF F16RV% THEN BEGIN
DOPEN#1, (F17FILE_NAME$), L(F17WORD_SIZE&)
  IF (F17RECORD_NUMBER > 0) THEN RECORD#1, F17RECORD_NUMBER, 1
  INPUT#1, F17RV$
  DCLOSE#1
BEND
RETURN
 
' FN_CHECK_WORD_VALIDITY(WORD$)
' RETURNS RV%
.FN18_CHECK_WORD_VALIDITY
F18WORD_INDEX = 0:F18WORD_LENGTH& = LEN(F18WORD$):F18VALID_WORD% = 0:F18MESSAGE$ = ""
F16FILE_NAME$ = "DICT" + RIGHT$("0" + MID$(STR$(F18WORD_LENGTH&), 2), 2):F16WORD_SIZE& = F18WORD_LENGTH&
GOSUB FN16_CONFIRM_FILE_EXISTS:F18VALID_WORD% = F16RV%
F18RV% = TRUE ' DEFAULT TO TRUE
IF F18VALID_WORD% THEN BEGIN
  F14WORD_TO_GUESS$ = F18WORD$
  GOSUB FN14_BINARY_SEARCH:F18WORD_INDEX = F14RV
  IF F18WORD_INDEX < 1 THEN BEGIN
    F18RV% = FALSE:F18MESSAGE$ = YELLOW$ + F18WORD$ + RED$ + " NOT IN WORD LIST!!!" + WHITE$
    CURSOR 0, 2:PRINT F18MESSAGE$
    SOUND 1, 3 * 256, 45 ' SOUND FX
    SLEEP 2
    F5NUM_CHARS% = SCREEN_WIDTH% - 1:F5TEXT_TO_REPEAT$ = " ":GOSUB FN5_GEN_STRING
    CURSOR 0, 2:PRINT F5RV$ ' CLEAR MESSAGE TEXT
  BEND
BEND
RETURN
 
' FN_COMPUTE_MAXIMUM_TURNS(WORD_LENGTH&)
' RETURNS RV&
.FN19_COMPUTE_MAXIMUM_TURNS
F19RV& = MINIMUM_ALLOWED_GUESSES& + (F19WORD_LENGTH& < 7) * -1
RETURN
 
' FN_RETRIEVE_LETTER_STATE(LETTER$)
.FN20_RETRIEVE_LETTER_STATE
' RETURNS INDEX INTO C_AICP$ (1, 2, 3, OR 4)
F20CHAR$ = MID$(LETTER_STATES$, ASC(F20LETTER$) - 64, 1)
F20RV% = INSTR(C_AICP$, F20CHAR$)
RETURN
 
' PROC_UPDATE_LETTER_STATE(LETTER$, STATE%)
.PROC21_UPDATE_LETTER_STATE
F20LETTER$ = P21LETTER$:GOSUB FN20_RETRIEVE_LETTER_STATE
P21CURRENT_STATE% = F20RV%:P21FINAL_STATE% = P21CURRENT_STATE%
IF P21STATE% = C_ABSENT& AND P21CURRENT_STATE% = C_BLANK& THEN P21FINAL_STATE% = P21STATE%
IF P21STATE% = C_PRESENT& AND P21CURRENT_STATE% <> C_CORRECT& THEN P21FINAL_STATE% = P21STATE%
IF P21STATE% = C_CORRECT& THEN P21FINAL_STATE% = P21STATE%
MID$(LETTER_STATES$, ASC(P21LETTER$)- 64, 1) = MID$(C_AICP$, P21FINAL_STATE%, 1)
RETURN
 
' PROC_DISPLAY_LETTER_STATES(X&, Y&)
.PROC22_DISPLAY_LETTER_STATES
FOR P22I% = 1 TO LEN(LETTER_STATES$)
  F20LETTER$ = CHR$(P22I% + 64)
  GOSUB FN20_RETRIEVE_LETTER_STATE
  P22CHAR$ = MID$(COL_AICP$, F20RV%, 1)
  CURSOR P22X& + P22I% - 1, P22Y&:PRINT P22CHAR$;RVSON$;CHR$(P22I% + 64);RVSOFF$;
NEXT P22I%
RETURN
 
' FN_PROMPT_FOR_GUESS()
.FN21_PROMPT_FOR_GUESS
' RETURNS RV$
F21VALID_WORD% = 0:RCURSOR F21X&, F21Y&
F5NUM_CHARS% = P1SIZE&:F5TEXT_TO_REPEAT$ = " ":GOSUB FN5_GEN_STRING:F21EMPTY$ = F5RV$
DO
  F21INPUT$ = "":CURSOR ON
  DO
    GETKEY F21CHAR$
    F21INPUT_LENGTH& = LEN(F21INPUT$)
    IF ((F21CHAR$ = BACK_SPACE$ OR F21CHAR$ = CRLEFT$) AND (F21INPUT_LENGTH& > 0)) THEN BEGIN
      F21INPUT$ = LEFT$(F21INPUT$, F21INPUT_LENGTH& - 1):PRINT BACK_SPACE$;
    BEND
    F21INPUT_LENGTH& = LEN(F21INPUT$)
    IF (F21CHAR$ >= "A" AND F21CHAR$ <= "Z") THEN BEGIN
      F22LETTER_TO_GUESS$ = F21CHAR$:F21IS_VIABLE% = TRUE:IF HARD_MODE% THEN BEGIN
        GOSUB FN22_IS_VIABLE_LETTER_GUESS:F21IS_VIABLE% = F22RV%
      BEND
      IF F21IS_VIABLE% AND (F21INPUT_LENGTH& < P1SIZE&) THEN F21INPUT$ = F21INPUT$ + F21CHAR$
    BEND
    F21COLOR$ = ORANGE$
    F21INPUT_LENGTH& = LEN(F21INPUT$)
    IF F21INPUT_LENGTH& < P1SIZE& THEN BEGIN
      F21COLOR$ = WHITE$
      CURSOR F21X&, F21Y&:PRINT F21EMPTY$ ' CLEAR OUT ANY PREVIOUSLY TYPED LETTERS
    BEND
    CURSOR F21X&, F21Y&:PRINT F21COLOR$;F21INPUT$;
  LOOP UNTIL (F21CHAR$ = CR$) AND (F21INPUT_LENGTH& = P1SIZE&)
  CURSOR OFF
  F21VALID_WORD% = TRUE
  IF STRICTLY_WORD_GUESSES% THEN BEGIN
    F18WORD$ = F21INPUT$:GOSUB FN18_CHECK_WORD_VALIDITY:F21VALID_WORD% = F18RV%
  BEND
  IF NOT F21VALID_WORD% THEN BEGIN
    CURSOR F21X&, F21Y&:PRINT F21EMPTY$:CURSOR F21X&, F21Y&
  BEND
LOOP UNTIL F21VALID_WORD%
F21RV$ = F21INPUT$
RETURN
 
' FN_IS_VIABLE_LETTER_GUESS(LETTER_TO_GUESS$)
.FN22_IS_VIABLE_LETTER_GUESS
' RETURNS RV% (-1 = TRUE, 0 = FALSE)
F20LETTER$ = F22LETTER_TO_GUESS$:GOSUB FN20_RETRIEVE_LETTER_STATE
F22RV% = (F20RV% <> C_ABSENT&)
RETURN

' :::::::::::::::::::::::::::::::::::::
' :: cOMPARE gUESS wITH mYSTERY wORD ::
' :::::::::::::::::::::::::::::::::::::
' FN_COMPARE_GUESS(GUESS$, TARGET$)
.FN23_COMPARE_GUESS
F23LEN& = LEN(F23TARGET$)
F10WORD$ = F23GUESS$:F10COUNT% = -ROTATION_AMOUNT%:GOSUB FN10_ROTATE:F23GUESS$ = F10RV$
FOR F23I% = 1 TO F23LEN&
  F23GUESS_CHAR$ = MID$(F23GUESS$, F23I%, 1)
  F23TARGET_CHAR$ = MID$(F23TARGET$, F23I%, 1)
  IF F23GUESS_CHAR$ = F23TARGET_CHAR$ THEN BEGIN
    F23MASK_CHAR$ = MID$(C_AICP$, C_CORRECT&, 1)
    MID$(F23GUESS$, F23I%) = F23MASK_CHAR$
    MID$(F23TARGET$, F23I%) = F23MASK_CHAR$
  BEND
NEXT F23I%
F23MASK$ = ""
FOR F23I% = 1 TO F23LEN&
  F23GUESS_CHAR$ = MID$(F23GUESS$, F23I%, 1)
  F23INDEX& = INSTR(F23TARGET$, F23GUESS_CHAR$)
  F23TARGET_CHAR$ = MID$(F23TARGET$, F23I%, 1)
  F23MASK_CHAR$ = MID$(C_AICP$, C_ABSENT&, 1) ' MASK CHAR (ABSENT)
  IF F23GUESS_CHAR$ = F23TARGET_CHAR$ THEN F23MASK_CHAR$ = F23TARGET_CHAR$
  IF F23INDEX& > 0 AND F23GUESS_CHAR$ <> F23TARGET_CHAR$ THEN BEGIN
    F23MASK_CHAR$ = MID$(C_AICP$, C_PRESENT&, 1) ' MASK CHAR (PRESENT)
    MID$(F23GUESS$, F23I%) = F23MASK_CHAR$
    MID$(F23TARGET$, F23INDEX&) = F23MASK_CHAR$
  BEND
F23MASK$ = F23MASK$ + F23MASK_CHAR$
' PRINT F23GUESS$, F23TARGET$, F23GUESS_CHAR$, F23INDEX&
NEXT F23I%
F23RV$ = F23MASK$
RETURN
 
' PROC_ANIMATE_FRAMES(X&, Y&, COL&, SLEEP_TIME)
.PROC23_ANIMATE_FRAMES
FOR P23I% = 1 TO FRAME_COUNT&
  P23CHAR& = FRAME_1& + VAL(MID$(FRAME_SEQUENCE$, P23I%, 1))
  P23COLOR& = (P23I% < FRAME_COUNT&) * -1 + (P23I% = FRAME_COUNT&) * -P23COL&
  T@&(P23X&, P23Y&) = P23CHAR&:C@&(P23X&, P23Y&) = P23COLOR&
  SOUND 1, 8192 - P23I% * 256, 3 ' SOUND FX
  VSYNC 0:SLEEP P23SLEEP_TIME
NEXT P23I%
RETURN
 
' PROC_REVEAL(GUESS$, MASK$, FINAL%)
.PROC24_REVEAL
P24GUESS_LEN% = LEN(P24GUESS$):RCURSOR P24X&, P24Y&
IF NOT P24FINAL% THEN BEGIN
  PRINT WHITE$;RVSON$;
  FOR P24I% = 1 TO P24GUESS_LEN%
    CURSOR P24X& + P24I% - 1, P24Y&:PRINT MID$(P24GUESS$, P24I%, 1);
  NEXT P24I%
  PRINT RVSOFF$
BEND
PRINT RVSON$;
FOR P24I% = 1 TO P24GUESS_LEN%
  P24C$ = MID$(P24MASK$, P24I%, 1)
  P24INDEX% = INSTR(C_AICP$, P24C$)
  IF P24INDEX% > 0 THEN BEGIN
    P24COLOR% = P24FINAL% * -(P_ORANGE) + (NOT P24FINAL%) * -ASC(MID$(COL_AICP$, P24INDEX%, 1))
    IF P24INDEX% = 2 THEN P24TONE% = 256 * 5  
    IF P24INDEX% = 3 THEN P24TONE% = 256 * 50
    IF P24INDEX% = 4 THEN P24TONE% = 256 * 25
    P24C$ = MID$(P24GUESS$, P24I%, 1)
    P23X& = P24X&:P23Y& = P24Y&:P23COL& = P24COLOR%:P23SLEEP_TIME = .12:GOSUB PROC23_ANIMATE_FRAMES
    SOUND 1, P24TONE%, 30 ' SOUND FX
    CURSOR P24X&, P24Y&:PRINT CHR$(P24COLOR%);P24C$;
    SLEEP .4
    P24X& = P24X& + 1
    P21LETTER$ = P24C$:P21STATE% = P24INDEX%:GOSUB PROC21_UPDATE_LETTER_STATE
  BEND
NEXT P24I%
PRINT RVSOFF$
RETURN
 
' PROC_SUSPENSE(X&, Y&, COUNT%, CH1&, CH2&, SLEEP_TIME)
.PROC25_SUSPENSE
CURSOR P25X&, P25Y&:PRINT WHITE$;
FOR P25I% = 1 TO P25COUNT%
  PRINT CHR$(P25CH2&);CHR$(P25CH1&);
  SOUND 1, 1200, 2 ' SOUND FX
  VSYNC 0:SLEEP P25SLEEP_TIME
  IF P25I% < P25COUNT% THEN PRINT CRLEFT$;CRLEFT$;CHR$(BLANK);
NEXT P25I%
RETURN
 
' PROC_CHARGE()
.PROC26_CHARGE
' G3(S.)C4(S.)E4(S.)G4(I.)E4(I)G4(H)
TEMPO 18
PLAY "T7O3.SGO4.SC.SE.IGIEHG"
RETURN
 
' PROC_WAH_WAH()
.PROC27_WAH_WAH
' G2(I)G2(I)G2(I)E2(WQ)F2(I))F2(I))F2(I)D2(WH)
TEMPO 17
PLAY "T7O2IGGG....HEIFFFWD"
RETURN
 
' FN_DERIVE_SUPERLATIVE(NUM_GUESSES&)
.FN24_DERIVE_SUPERLATIVE
F24RV$ = "INCONCEIVABLE?"
IF F24NUM_GUESSES& > 1 THEN F24RV$ = "EXTRAORDINARY"
IF F24NUM_GUESSES& > 2 THEN F24RV$ = "EXCEPTIONAL"
IF F24NUM_GUESSES& > 3 THEN F24RV$ = "SPLENDID"
IF F24NUM_GUESSES& > 4 THEN F24RV$ = "REMARKABLE"
IF F24NUM_GUESSES& > 5 THEN F24RV$ = "COMMENDABLE"
RETURN
 
' READ_FILE_OF_RECORD_COUNTS
.PROC28_READ_FILE_OF_RECORD_COUNTS
DOPEN#1, "DAT00.BIN"
FOR P28I& = LOWEST_WORD_LENGTH& TO HIGHEST_WORD_LENGTH&
  INPUT#1, RECORD_COUNTS%(P28I& - 2, 0):INPUT#1, RECORD_COUNTS%(P28I& - 2, 1)
NEXT P28I&
DCLOSE#1
RETURN
 
' ::::::::::::::::::::::::::::: 
' ::  ERROR HANDLING ROUTINE  : 
' ::::::::::::::::::::::::::::: 
' PROC_HANDLE_ERROR()
.PROC29_HANDLE_ERROR
IF ER <> 30 THEN BEGIN
  GOSUB PROC8_DEFAULT_COLORS:CURSOR ON:PRINT ESC$;"L";ESC$;"N"
  PRINT RED$;ERR$(ER);" ERROR ";WHITE$;"@LINE #";EL
  STOP
BEND
RESUME